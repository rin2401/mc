/**
 *	@author Nguyen Hua Phung
 *	@version 1.0
 *	23/10/2015
 * 	This file provides a simple version of code generator
 *
 */

package mc.codegen

import mc.checker._
import mc.utils._
import java.io.{PrintWriter, File}

object CodeGenerator extends Utils {
	val libName = "io"
	def init() = List(	Symbol("getInt",FunctionType(List(),IntType),CName(libName)),
						Symbol("putInt",FunctionType(List(IntType),VoidType),CName(libName)),
						Symbol("putIntLn",FunctionType(List(IntType),VoidType),CName(libName)),
						Symbol("getFloat",FunctionType(List(),FloatType),CName(libName)),
						Symbol("putFloat",FunctionType(List(FloatType),VoidType),CName(libName)),
						Symbol("putFloatLn",FunctionType(List(FloatType),VoidType),CName(libName)),
						Symbol("putBool",FunctionType(List(BoolType),VoidType),CName(libName)),
						Symbol("putBoolLn",FunctionType(List(BoolType),VoidType),CName(libName)),
						Symbol("putString",FunctionType(List(StringType),VoidType),CName(libName)),
						Symbol("putStringLn",FunctionType(List(StringType),VoidType),CName(libName)),
						Symbol("putLn",FunctionType(List(),VoidType),CName(libName))
					)
	def gen(ast:AST,dir:File) = {
		val gl = init()		 
		val gc = new CodeGenVisitor(ast,gl,dir)		
		gc.visit(ast, null)	 
	}
}

case class ClassType(cname:String) extends Type

//case class SubContext(emit:Emitter,decl:List[Decl]) 

case class SubBody(frame:Frame,sym:List[Symbol]) 

case class Flag(frame:Frame,val sym:List[Symbol],flag:Int)

class Access(val frame:Frame,val sym:List[Symbol],val isLeft:Boolean,val isFirst:Boolean)

trait Val
	case class Index(value:Int) extends Val
	case class CName(value:String) extends Val

class CodeGenVisitor(astTree:AST,env:List[Symbol],dir:File) extends BaseVisitor with Utils {
	val className = "MCClass"
	val path = dir.getPath()
	val emit = new Emitter(path+"/"+className+".j")
	/** generate code for default constructor 

	 *	@param consdecl the function declaration whose code will be generated by this method
	 *	@param frame the frame where the initialization happen 
	 *	@param o the referencing environment
	 */
	def genMETHOD(ast:FuncDecl,o:Any,frame:Frame) = {	
		val isInit = ast.name.name == "<init>" && ast.returnType == null
		val isClinit = ast.name.name == "<clinit>" && ast.returnType == null		
		val isMain = ast.name.name == "main" && ast.param.length == 0 && ast.returnType == VoidType
		val methodName = ast.name.name
		val input = if (isMain) List(ArrayPointerType(StringType)) else ast.param.map(_.varType)
		val output = if(isInit||isClinit) VoidType else ast.returnType
		val mtype =	FunctionType(input,output)
		
		emit.printout(emit.emitMETHOD(methodName, mtype, !isInit, frame))

		frame.enterScope(true);
		
		val glenv = o.asInstanceOf[List[Symbol]]
		//Generate code for parameter declarations
		val sympa = if (isInit) {
			emit.printout(emit.emitVAR(frame.getNewIndex,"this",ClassType(className),frame.getStartLabel,frame.getEndLabel,frame))
			glenv
		}
		else if (isMain) {
			emit.printout(emit.emitVAR(frame.getNewIndex,"args",ArrayPointerType(StringType),frame.getStartLabel,frame.getEndLabel,frame))
			glenv
		}
		else //other
			ast.param.foldLeft(glenv)((lst,x) => visit(x,Flag(frame,null,1)).asInstanceOf[Symbol]::lst)	

		//visit body
		if (isInit) {
			emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))
			emit.printout(emit.emitREADVAR("this",ClassType(className),0,frame))
			emit.printout(emit.emitINVOKESPECIAL(frame))
			emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
		}
		else if(isClinit){
			ast.body.asInstanceOf[Block].decl.map(x => {
				val lexeme = className + "." + x.asInstanceOf[VarDecl].variable.name
				emit.printout(emit.emitINITARRAY(lexeme,x.asInstanceOf[VarDecl].varType,frame))
			})
		}
		else 
			visit(ast.body,new Flag(frame,sympa,0))
		if (output == VoidType) emit.printout(emit.emitRETURN(VoidType,frame))
		emit.printout(emit.emitENDMETHOD(frame))
		frame.exitScope();
	}
	
	override def visitProgram(ast:Program,o:Any) = {
		emit.printout(emit.emitPROLOG(className, "java.lang.Object"))		
		//add global declarations to env symbol list
		val sym = ast.decl.foldLeft(env)((lst,x) => {
			val s = x match {
				case VarDecl(_,_) => visit(x,Flag(null,null,0)).asInstanceOf[Symbol]
				case FuncDecl(n,p,rt,_) => Symbol(n.name,FunctionType(p.map(_.varType),rt),CName(className))
			}
			s::lst
		})
		//visit function declarations
  		ast.decl.filter(_.isInstanceOf[FuncDecl]).map(visit(_,SubBody(null,sym)))
		// generate default constructor 
		genMETHOD(FuncDecl(Id("<init>"),List(),null,Block(List(),List())),o,new Frame("<init>",VoidType))
		// generate clinit static array
		val gloarr = ast.decl.filter(x => x match {
			case VarDecl(_,ArrayType(_,_)) => true
			case _ =>  false 
		})
		if(gloarr.size > 0) genMETHOD(FuncDecl(Id("<clinit>"),List(),null,Block(gloarr,List())),o,new Frame("<clinit>",VoidType))		

		emit.emitEPILOG()
	}
//Declaration
	override def visitFuncDecl(ast:FuncDecl,o:Any) = {
		val sub = o.asInstanceOf[SubBody]
		val frame = new Frame(ast.name.name,ast.returnType)
		genMETHOD(ast,sub.sym,frame)
	}

	override def visitVarDecl(ast:VarDecl,o:Any) = {
		val sub = o.asInstanceOf[Flag]
		val frame = sub.frame
		val mtype = ast.varType
		sub.flag match {
			case 0 => {//field
				val name = ast.variable.name
				emit.printout(emit.emitATTRIBUTE(name,mtype,false,null))
				Symbol(name,mtype,CName(className))
			}
			case 1 => {//param
				val index = frame.getNewIndex
				val name = "arg" + index
				emit.printout(emit.emitVAR(index,name,mtype,frame.getStartLabel,frame.getEndLabel,frame))
				Symbol(ast.variable.name,mtype,Index(index))
			}
			case 2 => {//local
				val index = frame.getNewIndex
				val name = ast.variable.name
				emit.printout(emit.emitVAR(index,name,mtype,frame.getStartLabel,frame.getEndLabel,frame))
				if(mtype.isInstanceOf[ArrayType]) emit.printout(emit.emitINITARRAY(index,mtype,frame)) 
				Symbol(name,mtype,Index(index))
			}
			case _ => null  
		}
	}
		
//Statement
	override def visitBlock(ast:Block,o:Any) = {
		val sub = o.asInstanceOf[Flag]
		val frame = sub.frame
		val env = sub.sym
		val isFirst = sub.flag == 0
		if(!isFirst) frame.enterScope(false)
		emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))
		//Generate code for local variable declarations
		val sym = ast.decl.asInstanceOf[List[VarDecl]].foldLeft(env)((lst,x) => visit(x,Flag(frame,null,2)).asInstanceOf[Symbol]::lst)			
		//Generate code for statement
		ast.stmt.map(x => {
			if(x.isInstanceOf[Literal]) null
			else if(x.isInstanceOf[Expr]) {
				val e = visit(x,new Access(frame,sym,false,true)).asInstanceOf[(String,Type)]
				emit.printout(e._1)
			}
			else if (x.isInstanceOf[Block]) 
				visit(x,Flag(frame,sym,1))
			else	
				visit(x,SubBody(frame,sym))
		})
		emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
		if(!isFirst) frame.exitScope()
	}

	override def visitIf(ast:If,o:Any) = {
		val sub = o.asInstanceOf[SubBody]
		val frame = sub.frame
		val env = sub.sym

		val c = visit(ast.expr,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
		emit.printout(c._1)
		val trueLabel = frame.getNewLabel()
		val falseLabel = frame.getNewLabel()
		emit.printout(emit.emitIFFALSE(falseLabel,frame))
		//val t = visit(ast.thenStmt,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
		val x = ast.thenStmt
		if(x.isInstanceOf[Literal]) null
		else if(x.isInstanceOf[Expr]) {
			val e = visit(x,new Access(frame,env,false,true)).asInstanceOf[(String,Type)]
			emit.printout(e._1)
		}
		else if (x.isInstanceOf[Block]) 
			visit(x,Flag(frame,env,1))
		else	
			visit(x,SubBody(frame,env))
		
		emit.printout(emit.emitGOTO(trueLabel,frame))
		emit.printout(emit.emitLABEL(falseLabel,frame))
		if(ast.elseStmt != None){
			val x = ast.elseStmt.get
			if(x.isInstanceOf[Literal]) null
			else if(x.isInstanceOf[Expr]) {
				val e = visit(x,new Access(frame,env,false,true)).asInstanceOf[(String,Type)]
				emit.printout(e._1)
			}
			else if (x.isInstanceOf[Block]) 
				visit(x,Flag(frame,env,1))
			else	
				visit(x,SubBody(frame,env))
		}
		emit.printout(emit.emitLABEL(trueLabel,frame))
	}

	override def visitFor(ast:For,o:Any) = {
		val sub = o.asInstanceOf[SubBody]
		val frame = sub.frame
		val env = sub.sym		
		
		frame.enterLoop()
		val label1 = frame.getNewLabel()		
		val brelabel = frame.getBreakLabel()
		val conlabel = frame.getContinueLabel()

		val e1 = visit(ast.expr1,new Access(frame,env,false,true)).asInstanceOf[(String,Type)] /// need fix
		emit.printout(e1._1)
		emit.printout(emit.emitLABEL(label1,frame))
		val e2 = visit(ast.expr2,new Access(frame,env,false,false)).asInstanceOf[(String,Type)] 
		emit.printout(e2._1)
		emit.printout(emit.emitIFFALSE(brelabel,frame))
		
		val x = ast.loop
		if(x.isInstanceOf[Literal]) null
		else if(x.isInstanceOf[Expr]) {
			val e = visit(x,new Access(frame,env,false,true)).asInstanceOf[(String,Type)] 
			emit.printout(e._1)
		}
		else if (x.isInstanceOf[Block]) 
			visit(x,Flag(frame,env,1))
		else	
			visit(x,SubBody(frame,env))
		emit.printout(emit.emitLABEL(conlabel,frame))
		val e3 = visit(ast.expr3,new Access(frame,env,false,true)).asInstanceOf[(String,Type)] /// need fix
		emit.printout(e3._1)
		emit.printout(emit.emitGOTO(label1,frame))		
		emit.printout(emit.emitLABEL(brelabel,frame))		
		frame.exitLoop()
	}

	override def visitDowhile(ast:Dowhile,o:Any) = {
		val sub = o.asInstanceOf[SubBody]
		val frame = sub.frame
		val env = sub.sym		
	
		frame.enterLoop()
		val brelabel = frame.getBreakLabel()
		val conlabel = frame.getContinueLabel()	
		emit.printout(emit.emitLABEL(conlabel,frame))

		ast.sl.map(x => {
			if(x.isInstanceOf[Literal]) null
			else if(x.isInstanceOf[Expr]) {
				val e = visit(x,new Access(frame,env,false,true)).asInstanceOf[(String,Type)]
				emit.printout(e._1)
			}
			else if (x.isInstanceOf[Block]) 
				visit(x,Flag(frame,env,1))
			else	
				visit(x,SubBody(frame,env))
		})
		val e = visit(ast.exp,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
		emit.printout(e._1)
		emit.printout(emit.emitIFTRUE(conlabel,frame))
		emit.printout(emit.emitLABEL(brelabel,frame))
		frame.exitLoop()
	}

	override def visitBreak(ast:Break.type,o:Any) = {
		val frame = o.asInstanceOf[SubBody].frame
		emit.printout(emit.emitGOTO(frame.getBreakLabel(),frame))
	}

	override def visitContinue(ast:Continue.type,o:Any) = {
		val frame = o.asInstanceOf[SubBody].frame
		emit.printout(emit.emitGOTO(frame.getContinueLabel(),frame))
	}

	override def visitReturn(ast:Return,o:Any) = {
		val sub = o.asInstanceOf[SubBody]
		val frame = sub.frame
		val env = sub.sym
		if(ast.expr == None) emit.printout(emit.emitRETURN(VoidType,frame))
		else {
			val e = visit(ast.expr.get,new Access(frame,env,false,false)).asInstanceOf[(String,Type)] /// need fix
			emit.printout(e._1)
			emit.printout(emit.emitRETURN(e._2,frame))
		}

	}

//Expression
	override def visitBinaryOp(ast:BinaryOp,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		val env = sub.sym
		val isFirst = sub.isFirst
		val isLeft = sub.isLeft
		val buffer = new StringBuffer()
		ast.op match {
			case "=" => {
				if(ast.left.isInstanceOf[ArrayCell]){
					val l = visit(ast.left,new Access(frame,env,true,false)).asInstanceOf[(String,Type)]
					buffer.append(l._1)					
					val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
					buffer.append(r._1)
					if(r._2!=l._2) buffer.append(emit.emitI2F(frame))
					if(!isFirst) buffer.append(emit.emitDUPX2(frame))					
					val name = ast.left.asInstanceOf[ArrayCell].arr.asInstanceOf[Id].name
					buffer.append(emit.emitWRITEVAR2(name,l._2,frame))
					(buffer.toString,l._2)
				}
				else {
					val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
					buffer.append(r._1)
					if(!isFirst) buffer.append(emit.emitDUP(frame))	
					val l = visit(ast.left,new Access(frame,env,true,false)).asInstanceOf[(String,Type)]											
					if(r._2!=l._2) buffer.append(emit.emitI2F(frame))					
					buffer.append(l._1)
					(buffer.toString,l._2)
				}
			}
			case "%" => {
				val l = visit(ast.left,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				buffer.append(l._1)
				buffer.append(r._1)
				buffer.append(emit.emitDIV(frame))
				if(isFirst) buffer.append(emit.emitPOP(frame))
				(buffer.toString,l._2)
			} 
			case "&&" => {
				val l = visit(ast.left,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				buffer.append(l._1)
				buffer.append(r._1)
				buffer.append(emit.emitANDOP(frame))
				if(isFirst) buffer.append(emit.emitPOP(frame))
				(buffer.toString,l._2)
			} 
			case "||" => {
				val l = visit(ast.left,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				buffer.append(l._1)
				buffer.append(r._1)
				buffer.append(emit.emitOROP(frame))
				if(isFirst) buffer.append(emit.emitPOP(frame))
				(buffer.toString,l._2)
			} 
			case _ => {
				val l = visit(ast.left,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				val r = visit(ast.right,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
				val otype = if(l._2==FloatType||r._2==FloatType) FloatType else IntType
				buffer.append(l._1)
				if(l._2 != otype) buffer.append(emit.emitI2F(frame)) 
				buffer.append(r._1)
				if(r._2 != otype) buffer.append(emit.emitI2F(frame)) 
				val rtype = ast.op match {
					case ("+"|"-") => buffer.append(emit.emitADDOP(ast.op,otype,frame)); otype
					case ("*"|"/") => buffer.append(emit.emitMULOP(ast.op,otype,frame)); otype
					case _ => buffer.append(emit.emitREOP(ast.op,otype,frame)); BoolType
				}
				if(isFirst) buffer.append(emit.emitPOP(frame))
				(buffer.toString,rtype)
			}			  
		}
	}

	override def visitUnaryOp(ast:UnaryOp,o:Any) = {
		val buffer = new StringBuffer()
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		val env = sub.sym
		val isFirst = sub.isFirst
		// val isLeft = sub.isLeft
		val b = visit(ast.body,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
		buffer.append(b._1)
		ast.op match {
			case "-" => buffer.append(emit.emitNEGOP(b._2,frame)) 
			case "!" => buffer.append(emit.emitNOT(b._2,frame))
		}
		if(isFirst) buffer.append(emit.emitPOP(frame))
		(buffer.toString,b._2) 
	}

	override def visitCallExpr(ast:CallExpr,o:Any) = {
		val buffer = new StringBuffer()		
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		val env = sub.sym
		val isFirst = sub.isFirst
		val sym = lookup(ast.method.name,env,(x:Symbol)=>x.name).get
		val cname = sym.value.asInstanceOf[CName].value
		val ftype = sym.typ.asInstanceOf[FunctionType]
		val in = ast.params.foldLeft(("",List[Type]()))((y,x) => {
			val (str1,typ1) = visit(x,new Access(frame,env,false,false)).asInstanceOf[(String,Type)]
			(y._1 + str1,y._2 :+ typ1)
		})
		//println(in._1)
		buffer.append(in._1)	
		buffer.append(emit.emitINVOKESTATIC(cname+"/"+ast.method.name,ftype,frame))
		(buffer.toString,ftype.output)		
	}

//LHS
	override def visitId(ast:Id,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		val sym = lookup(ast.name,sub.sym,(s:Symbol)=>s.name).get
		val mtype = sym.typ
		sym.value match {
			case Index(index) => { 
				val name = sym.name
				if(sub.isLeft)
					(emit.emitWRITEVAR(name,mtype,index,frame),mtype)
				else
					(emit.emitREADVAR(name,mtype,index,frame),mtype)
			}
			case CName(cname) => {
				val name = className+"."+sym.name		
				if(sub.isLeft) 					
					(emit.emitPUTSTATIC(name,mtype,frame),mtype)
				else
					(emit.emitGETSTATIC(name,mtype,frame),mtype)
			}
		}
	}

	override def visitArrayCell(ast:ArrayCell,o:Any) = {
		val buffer = new StringBuffer()
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		val idx = ast.idx.asInstanceOf[IntLiteral].value
		val arr = ast.arr.asInstanceOf[Id].name
		val sym = lookup(arr,sub.sym,(s:Symbol)=>s.name).get
		val mtype = sym.typ
		val et = mtype match {
			case ArrayType(_,t) => t 
			case ArrayPointerType(t) => t 
		}
		sym.value match {
			case Index(index) => { 
				val name = sym.name
				buffer.append(emit.emitREADVAR(name,mtype,index,frame)) 	//array ref
				buffer.append(emit.emitPUSHICONST(idx,frame))				//index							
				if(!sub.isLeft) buffer.append(emit.emitREADVAR2(name,et,frame))
			}
			case CName(cname) => {
				val name = className+"."+sym.name
				buffer.append(emit.emitGETSTATIC(name,mtype,frame))			//static array ref
				buffer.append(emit.emitPUSHICONST(idx,frame))				//index							
				if(!sub.isLeft) buffer.append(emit.emitREADVAR2(name,et,frame))
			}
		}
		(buffer.toString,et)
	}

//Literal
	override def visitIntLiteral(ast:IntLiteral,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		(emit.emitPUSHCONST(ast.value.toString,IntType,frame),IntType)
	}

	override def visitFloatLiteral(ast:FloatLiteral,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		(emit.emitPUSHCONST(ast.value.toString,FloatType,frame),FloatType)
	}
	
	override def visitStringLiteral(ast:StringLiteral,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		(emit.emitPUSHCONST(ast.value,StringType,frame),StringType)
	}

	override def visitBooleanLiteral(ast:BooleanLiteral,o:Any) = {
		val sub = o.asInstanceOf[Access]
		val frame = sub.frame
		
		(emit.emitPUSHCONST(ast.value.toString,BoolType,frame),BoolType)
	}

}